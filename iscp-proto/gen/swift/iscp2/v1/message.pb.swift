// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: iscp2/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iscp2_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Iscp2_V1_Message.OneOf_Message? = nil

  /// Connect
  var connectRequest: Iscp2_V1_ConnectRequest {
    get {
      if case .connectRequest(let v)? = message {return v}
      return Iscp2_V1_ConnectRequest()
    }
    set {message = .connectRequest(newValue)}
  }

  var connectResponse: Iscp2_V1_ConnectResponse {
    get {
      if case .connectResponse(let v)? = message {return v}
      return Iscp2_V1_ConnectResponse()
    }
    set {message = .connectResponse(newValue)}
  }

  var disconnect: Iscp2_V1_Disconnect {
    get {
      if case .disconnect(let v)? = message {return v}
      return Iscp2_V1_Disconnect()
    }
    set {message = .disconnect(newValue)}
  }

  /// Upstream
  var upstreamOpenRequest: Iscp2_V1_UpstreamOpenRequest {
    get {
      if case .upstreamOpenRequest(let v)? = message {return v}
      return Iscp2_V1_UpstreamOpenRequest()
    }
    set {message = .upstreamOpenRequest(newValue)}
  }

  var upstreamOpenResponse: Iscp2_V1_UpstreamOpenResponse {
    get {
      if case .upstreamOpenResponse(let v)? = message {return v}
      return Iscp2_V1_UpstreamOpenResponse()
    }
    set {message = .upstreamOpenResponse(newValue)}
  }

  var upstreamResumeRequest: Iscp2_V1_UpstreamResumeRequest {
    get {
      if case .upstreamResumeRequest(let v)? = message {return v}
      return Iscp2_V1_UpstreamResumeRequest()
    }
    set {message = .upstreamResumeRequest(newValue)}
  }

  var upstreamResumeResponse: Iscp2_V1_UpstreamResumeResponse {
    get {
      if case .upstreamResumeResponse(let v)? = message {return v}
      return Iscp2_V1_UpstreamResumeResponse()
    }
    set {message = .upstreamResumeResponse(newValue)}
  }

  var upstreamCloseRequest: Iscp2_V1_UpstreamCloseRequest {
    get {
      if case .upstreamCloseRequest(let v)? = message {return v}
      return Iscp2_V1_UpstreamCloseRequest()
    }
    set {message = .upstreamCloseRequest(newValue)}
  }

  var upstreamCloseResponse: Iscp2_V1_UpstreamCloseResponse {
    get {
      if case .upstreamCloseResponse(let v)? = message {return v}
      return Iscp2_V1_UpstreamCloseResponse()
    }
    set {message = .upstreamCloseResponse(newValue)}
  }

  var upstreamChunk: Iscp2_V1_UpstreamChunk {
    get {
      if case .upstreamChunk(let v)? = message {return v}
      return Iscp2_V1_UpstreamChunk()
    }
    set {message = .upstreamChunk(newValue)}
  }

  var upstreamChunkAck: Iscp2_V1_UpstreamChunkAck {
    get {
      if case .upstreamChunkAck(let v)? = message {return v}
      return Iscp2_V1_UpstreamChunkAck()
    }
    set {message = .upstreamChunkAck(newValue)}
  }

  var upstreamMetadata: Iscp2_V1_UpstreamMetadata {
    get {
      if case .upstreamMetadata(let v)? = message {return v}
      return Iscp2_V1_UpstreamMetadata()
    }
    set {message = .upstreamMetadata(newValue)}
  }

  var upstreamMetadataAck: Iscp2_V1_UpstreamMetadataAck {
    get {
      if case .upstreamMetadataAck(let v)? = message {return v}
      return Iscp2_V1_UpstreamMetadataAck()
    }
    set {message = .upstreamMetadataAck(newValue)}
  }

  /// Downstream
  var downstreamOpenRequest: Iscp2_V1_DownstreamOpenRequest {
    get {
      if case .downstreamOpenRequest(let v)? = message {return v}
      return Iscp2_V1_DownstreamOpenRequest()
    }
    set {message = .downstreamOpenRequest(newValue)}
  }

  var downstreamOpenResponse: Iscp2_V1_DownstreamOpenResponse {
    get {
      if case .downstreamOpenResponse(let v)? = message {return v}
      return Iscp2_V1_DownstreamOpenResponse()
    }
    set {message = .downstreamOpenResponse(newValue)}
  }

  var downstreamResumeRequest: Iscp2_V1_DownstreamResumeRequest {
    get {
      if case .downstreamResumeRequest(let v)? = message {return v}
      return Iscp2_V1_DownstreamResumeRequest()
    }
    set {message = .downstreamResumeRequest(newValue)}
  }

  var downstreamResumeResponse: Iscp2_V1_DownstreamResumeResponse {
    get {
      if case .downstreamResumeResponse(let v)? = message {return v}
      return Iscp2_V1_DownstreamResumeResponse()
    }
    set {message = .downstreamResumeResponse(newValue)}
  }

  var downstreamCloseRequest: Iscp2_V1_DownstreamCloseRequest {
    get {
      if case .downstreamCloseRequest(let v)? = message {return v}
      return Iscp2_V1_DownstreamCloseRequest()
    }
    set {message = .downstreamCloseRequest(newValue)}
  }

  var downstreamCloseResponse: Iscp2_V1_DownstreamCloseResponse {
    get {
      if case .downstreamCloseResponse(let v)? = message {return v}
      return Iscp2_V1_DownstreamCloseResponse()
    }
    set {message = .downstreamCloseResponse(newValue)}
  }

  var downstreamChunk: Iscp2_V1_DownstreamChunk {
    get {
      if case .downstreamChunk(let v)? = message {return v}
      return Iscp2_V1_DownstreamChunk()
    }
    set {message = .downstreamChunk(newValue)}
  }

  var downstreamChunkAck: Iscp2_V1_DownstreamChunkAck {
    get {
      if case .downstreamChunkAck(let v)? = message {return v}
      return Iscp2_V1_DownstreamChunkAck()
    }
    set {message = .downstreamChunkAck(newValue)}
  }

  var downstreamChunkAckComplete: Iscp2_V1_DownstreamChunkAckComplete {
    get {
      if case .downstreamChunkAckComplete(let v)? = message {return v}
      return Iscp2_V1_DownstreamChunkAckComplete()
    }
    set {message = .downstreamChunkAckComplete(newValue)}
  }

  var downstreamMetadata: Iscp2_V1_DownstreamMetadata {
    get {
      if case .downstreamMetadata(let v)? = message {return v}
      return Iscp2_V1_DownstreamMetadata()
    }
    set {message = .downstreamMetadata(newValue)}
  }

  var downstreamMetadataAck: Iscp2_V1_DownstreamMetadataAck {
    get {
      if case .downstreamMetadataAck(let v)? = message {return v}
      return Iscp2_V1_DownstreamMetadataAck()
    }
    set {message = .downstreamMetadataAck(newValue)}
  }

  /// Ping/Pong
  var ping: Iscp2_V1_Ping {
    get {
      if case .ping(let v)? = message {return v}
      return Iscp2_V1_Ping()
    }
    set {message = .ping(newValue)}
  }

  var pong: Iscp2_V1_Pong {
    get {
      if case .pong(let v)? = message {return v}
      return Iscp2_V1_Pong()
    }
    set {message = .pong(newValue)}
  }

  /// E2E Call
  var upstreamCall: Iscp2_V1_UpstreamCall {
    get {
      if case .upstreamCall(let v)? = message {return v}
      return Iscp2_V1_UpstreamCall()
    }
    set {message = .upstreamCall(newValue)}
  }

  var upstreamCallAck: Iscp2_V1_UpstreamCallAck {
    get {
      if case .upstreamCallAck(let v)? = message {return v}
      return Iscp2_V1_UpstreamCallAck()
    }
    set {message = .upstreamCallAck(newValue)}
  }

  var downstreamCall: Iscp2_V1_DownstreamCall {
    get {
      if case .downstreamCall(let v)? = message {return v}
      return Iscp2_V1_DownstreamCall()
    }
    set {message = .downstreamCall(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    /// Connect
    case connectRequest(Iscp2_V1_ConnectRequest)
    case connectResponse(Iscp2_V1_ConnectResponse)
    case disconnect(Iscp2_V1_Disconnect)
    /// Upstream
    case upstreamOpenRequest(Iscp2_V1_UpstreamOpenRequest)
    case upstreamOpenResponse(Iscp2_V1_UpstreamOpenResponse)
    case upstreamResumeRequest(Iscp2_V1_UpstreamResumeRequest)
    case upstreamResumeResponse(Iscp2_V1_UpstreamResumeResponse)
    case upstreamCloseRequest(Iscp2_V1_UpstreamCloseRequest)
    case upstreamCloseResponse(Iscp2_V1_UpstreamCloseResponse)
    case upstreamChunk(Iscp2_V1_UpstreamChunk)
    case upstreamChunkAck(Iscp2_V1_UpstreamChunkAck)
    case upstreamMetadata(Iscp2_V1_UpstreamMetadata)
    case upstreamMetadataAck(Iscp2_V1_UpstreamMetadataAck)
    /// Downstream
    case downstreamOpenRequest(Iscp2_V1_DownstreamOpenRequest)
    case downstreamOpenResponse(Iscp2_V1_DownstreamOpenResponse)
    case downstreamResumeRequest(Iscp2_V1_DownstreamResumeRequest)
    case downstreamResumeResponse(Iscp2_V1_DownstreamResumeResponse)
    case downstreamCloseRequest(Iscp2_V1_DownstreamCloseRequest)
    case downstreamCloseResponse(Iscp2_V1_DownstreamCloseResponse)
    case downstreamChunk(Iscp2_V1_DownstreamChunk)
    case downstreamChunkAck(Iscp2_V1_DownstreamChunkAck)
    case downstreamChunkAckComplete(Iscp2_V1_DownstreamChunkAckComplete)
    case downstreamMetadata(Iscp2_V1_DownstreamMetadata)
    case downstreamMetadataAck(Iscp2_V1_DownstreamMetadataAck)
    /// Ping/Pong
    case ping(Iscp2_V1_Ping)
    case pong(Iscp2_V1_Pong)
    /// E2E Call
    case upstreamCall(Iscp2_V1_UpstreamCall)
    case upstreamCallAck(Iscp2_V1_UpstreamCallAck)
    case downstreamCall(Iscp2_V1_DownstreamCall)

  #if !swift(>=4.1)
    static func ==(lhs: Iscp2_V1_Message.OneOf_Message, rhs: Iscp2_V1_Message.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.connectRequest, .connectRequest): return {
        guard case .connectRequest(let l) = lhs, case .connectRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectResponse, .connectResponse): return {
        guard case .connectResponse(let l) = lhs, case .connectResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disconnect, .disconnect): return {
        guard case .disconnect(let l) = lhs, case .disconnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamOpenRequest, .upstreamOpenRequest): return {
        guard case .upstreamOpenRequest(let l) = lhs, case .upstreamOpenRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamOpenResponse, .upstreamOpenResponse): return {
        guard case .upstreamOpenResponse(let l) = lhs, case .upstreamOpenResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamResumeRequest, .upstreamResumeRequest): return {
        guard case .upstreamResumeRequest(let l) = lhs, case .upstreamResumeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamResumeResponse, .upstreamResumeResponse): return {
        guard case .upstreamResumeResponse(let l) = lhs, case .upstreamResumeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamCloseRequest, .upstreamCloseRequest): return {
        guard case .upstreamCloseRequest(let l) = lhs, case .upstreamCloseRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamCloseResponse, .upstreamCloseResponse): return {
        guard case .upstreamCloseResponse(let l) = lhs, case .upstreamCloseResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamChunk, .upstreamChunk): return {
        guard case .upstreamChunk(let l) = lhs, case .upstreamChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamChunkAck, .upstreamChunkAck): return {
        guard case .upstreamChunkAck(let l) = lhs, case .upstreamChunkAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamMetadata, .upstreamMetadata): return {
        guard case .upstreamMetadata(let l) = lhs, case .upstreamMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamMetadataAck, .upstreamMetadataAck): return {
        guard case .upstreamMetadataAck(let l) = lhs, case .upstreamMetadataAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamOpenRequest, .downstreamOpenRequest): return {
        guard case .downstreamOpenRequest(let l) = lhs, case .downstreamOpenRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamOpenResponse, .downstreamOpenResponse): return {
        guard case .downstreamOpenResponse(let l) = lhs, case .downstreamOpenResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamResumeRequest, .downstreamResumeRequest): return {
        guard case .downstreamResumeRequest(let l) = lhs, case .downstreamResumeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamResumeResponse, .downstreamResumeResponse): return {
        guard case .downstreamResumeResponse(let l) = lhs, case .downstreamResumeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamCloseRequest, .downstreamCloseRequest): return {
        guard case .downstreamCloseRequest(let l) = lhs, case .downstreamCloseRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamCloseResponse, .downstreamCloseResponse): return {
        guard case .downstreamCloseResponse(let l) = lhs, case .downstreamCloseResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamChunk, .downstreamChunk): return {
        guard case .downstreamChunk(let l) = lhs, case .downstreamChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamChunkAck, .downstreamChunkAck): return {
        guard case .downstreamChunkAck(let l) = lhs, case .downstreamChunkAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamChunkAckComplete, .downstreamChunkAckComplete): return {
        guard case .downstreamChunkAckComplete(let l) = lhs, case .downstreamChunkAckComplete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamMetadata, .downstreamMetadata): return {
        guard case .downstreamMetadata(let l) = lhs, case .downstreamMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamMetadataAck, .downstreamMetadataAck): return {
        guard case .downstreamMetadataAck(let l) = lhs, case .downstreamMetadataAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamCall, .upstreamCall): return {
        guard case .upstreamCall(let l) = lhs, case .upstreamCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamCallAck, .upstreamCallAck): return {
        guard case .upstreamCallAck(let l) = lhs, case .upstreamCallAck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamCall, .downstreamCall): return {
        guard case .downstreamCall(let l) = lhs, case .downstreamCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Iscp2_V1_Message: @unchecked Sendable {}
extension Iscp2_V1_Message.OneOf_Message: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iscp2.v1"

extension Iscp2_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connect_request"),
    2: .standard(proto: "connect_response"),
    3: .same(proto: "disconnect"),
    64: .standard(proto: "upstream_open_request"),
    65: .standard(proto: "upstream_open_response"),
    66: .standard(proto: "upstream_resume_request"),
    67: .standard(proto: "upstream_resume_response"),
    68: .standard(proto: "upstream_close_request"),
    69: .standard(proto: "upstream_close_response"),
    70: .standard(proto: "upstream_chunk"),
    71: .standard(proto: "upstream_chunk_ack"),
    72: .standard(proto: "upstream_metadata"),
    73: .standard(proto: "upstream_metadata_ack"),
    128: .standard(proto: "downstream_open_request"),
    129: .standard(proto: "downstream_open_response"),
    130: .standard(proto: "downstream_resume_request"),
    131: .standard(proto: "downstream_resume_response"),
    132: .standard(proto: "downstream_close_request"),
    133: .standard(proto: "downstream_close_response"),
    134: .standard(proto: "downstream_chunk"),
    135: .standard(proto: "downstream_chunk_ack"),
    136: .standard(proto: "downstream_chunk_ack_complete"),
    137: .standard(proto: "downstream_metadata"),
    138: .standard(proto: "downstream_metadata_ack"),
    192: .same(proto: "ping"),
    193: .same(proto: "pong"),
    256: .standard(proto: "upstream_call"),
    257: .standard(proto: "upstream_call_ack"),
    258: .standard(proto: "downstream_call"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iscp2_V1_ConnectRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .connectRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .connectRequest(v)
        }
      }()
      case 2: try {
        var v: Iscp2_V1_ConnectResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .connectResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .connectResponse(v)
        }
      }()
      case 3: try {
        var v: Iscp2_V1_Disconnect?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .disconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .disconnect(v)
        }
      }()
      case 64: try {
        var v: Iscp2_V1_UpstreamOpenRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamOpenRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamOpenRequest(v)
        }
      }()
      case 65: try {
        var v: Iscp2_V1_UpstreamOpenResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamOpenResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamOpenResponse(v)
        }
      }()
      case 66: try {
        var v: Iscp2_V1_UpstreamResumeRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamResumeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamResumeRequest(v)
        }
      }()
      case 67: try {
        var v: Iscp2_V1_UpstreamResumeResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamResumeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamResumeResponse(v)
        }
      }()
      case 68: try {
        var v: Iscp2_V1_UpstreamCloseRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamCloseRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamCloseRequest(v)
        }
      }()
      case 69: try {
        var v: Iscp2_V1_UpstreamCloseResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamCloseResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamCloseResponse(v)
        }
      }()
      case 70: try {
        var v: Iscp2_V1_UpstreamChunk?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamChunk(v)
        }
      }()
      case 71: try {
        var v: Iscp2_V1_UpstreamChunkAck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamChunkAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamChunkAck(v)
        }
      }()
      case 72: try {
        var v: Iscp2_V1_UpstreamMetadata?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamMetadata(v)
        }
      }()
      case 73: try {
        var v: Iscp2_V1_UpstreamMetadataAck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamMetadataAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamMetadataAck(v)
        }
      }()
      case 128: try {
        var v: Iscp2_V1_DownstreamOpenRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamOpenRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamOpenRequest(v)
        }
      }()
      case 129: try {
        var v: Iscp2_V1_DownstreamOpenResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamOpenResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamOpenResponse(v)
        }
      }()
      case 130: try {
        var v: Iscp2_V1_DownstreamResumeRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamResumeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamResumeRequest(v)
        }
      }()
      case 131: try {
        var v: Iscp2_V1_DownstreamResumeResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamResumeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamResumeResponse(v)
        }
      }()
      case 132: try {
        var v: Iscp2_V1_DownstreamCloseRequest?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamCloseRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamCloseRequest(v)
        }
      }()
      case 133: try {
        var v: Iscp2_V1_DownstreamCloseResponse?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamCloseResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamCloseResponse(v)
        }
      }()
      case 134: try {
        var v: Iscp2_V1_DownstreamChunk?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamChunk(v)
        }
      }()
      case 135: try {
        var v: Iscp2_V1_DownstreamChunkAck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamChunkAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamChunkAck(v)
        }
      }()
      case 136: try {
        var v: Iscp2_V1_DownstreamChunkAckComplete?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamChunkAckComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamChunkAckComplete(v)
        }
      }()
      case 137: try {
        var v: Iscp2_V1_DownstreamMetadata?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamMetadata(v)
        }
      }()
      case 138: try {
        var v: Iscp2_V1_DownstreamMetadataAck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamMetadataAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamMetadataAck(v)
        }
      }()
      case 192: try {
        var v: Iscp2_V1_Ping?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .ping(v)
        }
      }()
      case 193: try {
        var v: Iscp2_V1_Pong?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .pong(v)
        }
      }()
      case 256: try {
        var v: Iscp2_V1_UpstreamCall?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamCall(v)
        }
      }()
      case 257: try {
        var v: Iscp2_V1_UpstreamCallAck?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .upstreamCallAck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .upstreamCallAck(v)
        }
      }()
      case 258: try {
        var v: Iscp2_V1_DownstreamCall?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .downstreamCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .downstreamCall(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.message {
    case .connectRequest?: try {
      guard case .connectRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .connectResponse?: try {
      guard case .connectResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .upstreamOpenRequest?: try {
      guard case .upstreamOpenRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }()
    case .upstreamOpenResponse?: try {
      guard case .upstreamOpenResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .upstreamResumeRequest?: try {
      guard case .upstreamResumeRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .upstreamResumeResponse?: try {
      guard case .upstreamResumeResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
    }()
    case .upstreamCloseRequest?: try {
      guard case .upstreamCloseRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
    }()
    case .upstreamCloseResponse?: try {
      guard case .upstreamCloseResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
    }()
    case .upstreamChunk?: try {
      guard case .upstreamChunk(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case .upstreamChunkAck?: try {
      guard case .upstreamChunkAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case .upstreamMetadata?: try {
      guard case .upstreamMetadata(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .upstreamMetadataAck?: try {
      guard case .upstreamMetadataAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
    }()
    case .downstreamOpenRequest?: try {
      guard case .downstreamOpenRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
    }()
    case .downstreamOpenResponse?: try {
      guard case .downstreamOpenResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .downstreamResumeRequest?: try {
      guard case .downstreamResumeRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .downstreamResumeResponse?: try {
      guard case .downstreamResumeResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
    }()
    case .downstreamCloseRequest?: try {
      guard case .downstreamCloseRequest(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
    }()
    case .downstreamCloseResponse?: try {
      guard case .downstreamCloseResponse(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
    }()
    case .downstreamChunk?: try {
      guard case .downstreamChunk(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
    }()
    case .downstreamChunkAck?: try {
      guard case .downstreamChunkAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
    }()
    case .downstreamChunkAckComplete?: try {
      guard case .downstreamChunkAckComplete(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
    }()
    case .downstreamMetadata?: try {
      guard case .downstreamMetadata(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 137)
    }()
    case .downstreamMetadataAck?: try {
      guard case .downstreamMetadataAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 138)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 192)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 193)
    }()
    case .upstreamCall?: try {
      guard case .upstreamCall(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 256)
    }()
    case .upstreamCallAck?: try {
      guard case .upstreamCallAck(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 257)
    }()
    case .downstreamCall?: try {
      guard case .downstreamCall(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 258)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_Message, rhs: Iscp2_V1_Message) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
