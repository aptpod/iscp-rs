// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: iscp2/v1/upstream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iscp2_V1_UpstreamOpenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var sessionID: String = String()

  var ackInterval: UInt32 = 0

  var expiryInterval: UInt32 = 0

  var dataIds: [Iscp2_V1_DataID] = []

  var qos: Iscp2_V1_QoS = .unreliable

  var extensionFields: Iscp2_V1_Extensions_UpstreamOpenRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamOpenRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamOpenRequestExtensionFields? = nil
}

struct Iscp2_V1_UpstreamOpenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var assignedStreamID: Data = Data()

  var assignedStreamIDAlias: UInt32 = 0

  var dataIDAliases: Dictionary<UInt32,Iscp2_V1_DataID> = [:]

  var serverTime: Int64 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_UpstreamOpenResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamOpenResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamOpenResponseExtensionFields? = nil
}

struct Iscp2_V1_UpstreamResumeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var streamID: Data = Data()

  var extensionFields: Iscp2_V1_Extensions_UpstreamResumeRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamResumeRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamResumeRequestExtensionFields? = nil
}

struct Iscp2_V1_UpstreamResumeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var assignedStreamIDAlias: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_UpstreamResumeResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamResumeResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamResumeResponseExtensionFields? = nil
}

struct Iscp2_V1_UpstreamCloseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var streamID: Data = Data()

  var totalDataPoints: UInt64 = 0

  var finalSequenceNumber: UInt32 = 0

  var extensionFields: Iscp2_V1_Extensions_UpstreamCloseRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamCloseRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamCloseRequestExtensionFields? = nil
}

struct Iscp2_V1_UpstreamCloseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_UpstreamCloseResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamCloseResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamCloseResponseExtensionFields? = nil
}

struct Iscp2_V1_UpstreamChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDAlias: UInt32 = 0

  var streamChunk: Iscp2_V1_StreamChunk {
    get {return _streamChunk ?? Iscp2_V1_StreamChunk()}
    set {_streamChunk = newValue}
  }
  /// Returns true if `streamChunk` has been explicitly set.
  var hasStreamChunk: Bool {return self._streamChunk != nil}
  /// Clears the value of `streamChunk`. Subsequent reads from it will return its default value.
  mutating func clearStreamChunk() {self._streamChunk = nil}

  var dataIds: [Iscp2_V1_DataID] = []

  var extensionFields: Iscp2_V1_Extensions_UpstreamChunkExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamChunkExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _streamChunk: Iscp2_V1_StreamChunk? = nil
  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamChunkExtensionFields? = nil
}

struct Iscp2_V1_UpstreamChunkAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDAlias: UInt32 = 0

  var results: [Iscp2_V1_UpstreamChunkResult] = []

  var dataIDAliases: Dictionary<UInt32,Iscp2_V1_DataID> = [:]

  var extensionFields: Iscp2_V1_Extensions_UpstreamChunkAckExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamChunkAckExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamChunkAckExtensionFields? = nil
}

struct Iscp2_V1_UpstreamMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var metadata: Iscp2_V1_UpstreamMetadata.OneOf_Metadata? = nil

  var baseTime: Iscp2_V1_BaseTime {
    get {
      if case .baseTime(let v)? = metadata {return v}
      return Iscp2_V1_BaseTime()
    }
    set {metadata = .baseTime(newValue)}
  }

  var extensionFields: Iscp2_V1_Extensions_UpstreamMetadataExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamMetadataExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Metadata: Equatable {
    case baseTime(Iscp2_V1_BaseTime)

  #if !swift(>=4.1)
    static func ==(lhs: Iscp2_V1_UpstreamMetadata.OneOf_Metadata, rhs: Iscp2_V1_UpstreamMetadata.OneOf_Metadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.baseTime, .baseTime): return {
        guard case .baseTime(let l) = lhs, case .baseTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamMetadataExtensionFields? = nil
}

struct Iscp2_V1_UpstreamMetadataAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_UpstreamMetadataAckExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamMetadataAckExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamMetadataAckExtensionFields? = nil
}

struct Iscp2_V1_UpstreamChunkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_UpstreamChunkResultExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_UpstreamChunkResultExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_UpstreamChunkResultExtensionFields? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Iscp2_V1_UpstreamOpenRequest: @unchecked Sendable {}
extension Iscp2_V1_UpstreamOpenResponse: @unchecked Sendable {}
extension Iscp2_V1_UpstreamResumeRequest: @unchecked Sendable {}
extension Iscp2_V1_UpstreamResumeResponse: @unchecked Sendable {}
extension Iscp2_V1_UpstreamCloseRequest: @unchecked Sendable {}
extension Iscp2_V1_UpstreamCloseResponse: @unchecked Sendable {}
extension Iscp2_V1_UpstreamChunk: @unchecked Sendable {}
extension Iscp2_V1_UpstreamChunkAck: @unchecked Sendable {}
extension Iscp2_V1_UpstreamMetadata: @unchecked Sendable {}
extension Iscp2_V1_UpstreamMetadata.OneOf_Metadata: @unchecked Sendable {}
extension Iscp2_V1_UpstreamMetadataAck: @unchecked Sendable {}
extension Iscp2_V1_UpstreamChunkResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iscp2.v1"

extension Iscp2_V1_UpstreamOpenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamOpenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "session_id"),
    3: .standard(proto: "ack_interval"),
    5: .standard(proto: "expiry_interval"),
    6: .standard(proto: "data_ids"),
    7: .same(proto: "qos"),
    8: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.ackInterval) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.expiryInterval) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.dataIds) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.qos) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if self.ackInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.ackInterval, fieldNumber: 3)
    }
    if self.expiryInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiryInterval, fieldNumber: 5)
    }
    if !self.dataIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataIds, fieldNumber: 6)
    }
    if self.qos != .unreliable {
      try visitor.visitSingularEnumField(value: self.qos, fieldNumber: 7)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamOpenRequest, rhs: Iscp2_V1_UpstreamOpenRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.ackInterval != rhs.ackInterval {return false}
    if lhs.expiryInterval != rhs.expiryInterval {return false}
    if lhs.dataIds != rhs.dataIds {return false}
    if lhs.qos != rhs.qos {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamOpenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamOpenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "assigned_stream_id"),
    3: .standard(proto: "assigned_stream_id_alias"),
    4: .standard(proto: "data_id_aliases"),
    5: .standard(proto: "server_time"),
    6: .standard(proto: "result_code"),
    7: .standard(proto: "result_string"),
    8: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.assignedStreamID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.assignedStreamIDAlias) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: &self.dataIDAliases) }()
      case 5: try { try decoder.decodeSingularSInt64Field(value: &self.serverTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.assignedStreamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assignedStreamID, fieldNumber: 2)
    }
    if self.assignedStreamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.assignedStreamIDAlias, fieldNumber: 3)
    }
    if !self.dataIDAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: self.dataIDAliases, fieldNumber: 4)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularSInt64Field(value: self.serverTime, fieldNumber: 5)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 6)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 7)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamOpenResponse, rhs: Iscp2_V1_UpstreamOpenResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.assignedStreamID != rhs.assignedStreamID {return false}
    if lhs.assignedStreamIDAlias != rhs.assignedStreamIDAlias {return false}
    if lhs.dataIDAliases != rhs.dataIDAliases {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamResumeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "stream_id"),
    3: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamID, fieldNumber: 2)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamResumeRequest, rhs: Iscp2_V1_UpstreamResumeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamResumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamResumeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "assigned_stream_id_alias"),
    3: .standard(proto: "result_code"),
    4: .standard(proto: "result_string"),
    5: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.assignedStreamIDAlias) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.assignedStreamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.assignedStreamIDAlias, fieldNumber: 2)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 3)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 4)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamResumeResponse, rhs: Iscp2_V1_UpstreamResumeResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.assignedStreamIDAlias != rhs.assignedStreamIDAlias {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamCloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamCloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "stream_id"),
    3: .standard(proto: "total_data_points"),
    4: .standard(proto: "final_sequence_number"),
    5: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalDataPoints) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.finalSequenceNumber) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamID, fieldNumber: 2)
    }
    if self.totalDataPoints != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalDataPoints, fieldNumber: 3)
    }
    if self.finalSequenceNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.finalSequenceNumber, fieldNumber: 4)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamCloseRequest, rhs: Iscp2_V1_UpstreamCloseRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.totalDataPoints != rhs.totalDataPoints {return false}
    if lhs.finalSequenceNumber != rhs.finalSequenceNumber {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamCloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamCloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamCloseResponse, rhs: Iscp2_V1_UpstreamCloseResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_alias"),
    2: .standard(proto: "stream_chunk"),
    3: .standard(proto: "data_ids"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamChunk) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.dataIds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 1)
    }
    try { if let v = self._streamChunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.dataIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataIds, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamChunk, rhs: Iscp2_V1_UpstreamChunk) -> Bool {
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs._streamChunk != rhs._streamChunk {return false}
    if lhs.dataIds != rhs.dataIds {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamChunkAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamChunkAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_alias"),
    2: .same(proto: "results"),
    3: .standard(proto: "data_id_aliases"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: &self.dataIDAliases) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 2)
    }
    if !self.dataIDAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: self.dataIDAliases, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamChunkAck, rhs: Iscp2_V1_UpstreamChunkAck) -> Bool {
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs.results != rhs.results {return false}
    if lhs.dataIDAliases != rhs.dataIDAliases {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "base_time"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try {
        var v: Iscp2_V1_BaseTime?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .baseTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .baseTime(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    try { if case .baseTime(let v)? = self.metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamMetadata, rhs: Iscp2_V1_UpstreamMetadata) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamMetadataAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamMetadataAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamMetadataAck, rhs: Iscp2_V1_UpstreamMetadataAck) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamChunkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamChunkResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sequenceNumber) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sequenceNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequenceNumber, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamChunkResult, rhs: Iscp2_V1_UpstreamChunkResult) -> Bool {
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
