// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: iscp2/v1/downstream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Iscp2_V1_DownstreamOpenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var desiredStreamIDAlias: UInt32 = 0

  var downstreamFilters: [Iscp2_V1_DownstreamFilter] = []

  var expiryInterval: UInt32 = 0

  var dataIDAliases: Dictionary<UInt32,Iscp2_V1_DataID> = [:]

  var qos: Iscp2_V1_QoS = .unreliable

  var extensionFields: Iscp2_V1_Extensions_DownstreamOpenRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamOpenRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var omitEmptyChunk: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamOpenRequestExtensionFields? = nil
}

struct Iscp2_V1_DownstreamOpenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var assignedStreamID: Data = Data()

  var serverTime: Int64 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamOpenResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamOpenResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamOpenResponseExtensionFields? = nil
}

struct Iscp2_V1_DownstreamResumeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var streamID: Data = Data()

  var desiredStreamIDAlias: UInt32 = 0

  var extensionFields: Iscp2_V1_Extensions_DownstreamResumeRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamResumeRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamResumeRequestExtensionFields? = nil
}

struct Iscp2_V1_DownstreamResumeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamResumeResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamResumeResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamResumeResponseExtensionFields? = nil
}

struct Iscp2_V1_DownstreamCloseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var streamID: Data = Data()

  var extensionFields: Iscp2_V1_Extensions_DownstreamCloseRequestExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamCloseRequestExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamCloseRequestExtensionFields? = nil
}

struct Iscp2_V1_DownstreamCloseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamCloseResponseExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamCloseResponseExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamCloseResponseExtensionFields? = nil
}

struct Iscp2_V1_DownstreamChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDAlias: UInt32 = 0

  var upstreamOrAlias: Iscp2_V1_DownstreamChunk.OneOf_UpstreamOrAlias? = nil

  var upstreamInfo: Iscp2_V1_UpstreamInfo {
    get {
      if case .upstreamInfo(let v)? = upstreamOrAlias {return v}
      return Iscp2_V1_UpstreamInfo()
    }
    set {upstreamOrAlias = .upstreamInfo(newValue)}
  }

  var upstreamAlias: UInt32 {
    get {
      if case .upstreamAlias(let v)? = upstreamOrAlias {return v}
      return 0
    }
    set {upstreamOrAlias = .upstreamAlias(newValue)}
  }

  var streamChunk: Iscp2_V1_StreamChunk {
    get {return _streamChunk ?? Iscp2_V1_StreamChunk()}
    set {_streamChunk = newValue}
  }
  /// Returns true if `streamChunk` has been explicitly set.
  var hasStreamChunk: Bool {return self._streamChunk != nil}
  /// Clears the value of `streamChunk`. Subsequent reads from it will return its default value.
  mutating func clearStreamChunk() {self._streamChunk = nil}

  var extensionFields: Iscp2_V1_Extensions_DownstreamChunkExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamChunkExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_UpstreamOrAlias: Equatable {
    case upstreamInfo(Iscp2_V1_UpstreamInfo)
    case upstreamAlias(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: Iscp2_V1_DownstreamChunk.OneOf_UpstreamOrAlias, rhs: Iscp2_V1_DownstreamChunk.OneOf_UpstreamOrAlias) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.upstreamInfo, .upstreamInfo): return {
        guard case .upstreamInfo(let l) = lhs, case .upstreamInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamAlias, .upstreamAlias): return {
        guard case .upstreamAlias(let l) = lhs, case .upstreamAlias(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _streamChunk: Iscp2_V1_StreamChunk? = nil
  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamChunkExtensionFields? = nil
}

struct Iscp2_V1_DownstreamChunkAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDAlias: UInt32 = 0

  var ackID: UInt32 = 0

  var results: [Iscp2_V1_DownstreamChunkResult] = []

  var upstreamAliases: Dictionary<UInt32,Iscp2_V1_UpstreamInfo> = [:]

  var dataIDAliases: Dictionary<UInt32,Iscp2_V1_DataID> = [:]

  var extensionFields: Iscp2_V1_Extensions_DownstreamChunkAckExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamChunkAckExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamChunkAckExtensionFields? = nil
}

struct Iscp2_V1_DownstreamChunkAckComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDAlias: UInt32 = 0

  var ackID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamChunkAckCompleteExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamChunkAckCompleteExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamChunkAckCompleteExtensionFields? = nil
}

struct Iscp2_V1_DownstreamMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var streamIDAlias: UInt32 = 0

  var metadata: Iscp2_V1_DownstreamMetadata.OneOf_Metadata? = nil

  var baseTime: Iscp2_V1_BaseTime {
    get {
      if case .baseTime(let v)? = metadata {return v}
      return Iscp2_V1_BaseTime()
    }
    set {metadata = .baseTime(newValue)}
  }

  var upstreamOpen: Iscp2_V1_UpstreamOpen {
    get {
      if case .upstreamOpen(let v)? = metadata {return v}
      return Iscp2_V1_UpstreamOpen()
    }
    set {metadata = .upstreamOpen(newValue)}
  }

  var upstreamAbnormalClose: Iscp2_V1_UpstreamAbnormalClose {
    get {
      if case .upstreamAbnormalClose(let v)? = metadata {return v}
      return Iscp2_V1_UpstreamAbnormalClose()
    }
    set {metadata = .upstreamAbnormalClose(newValue)}
  }

  var upstreamResume: Iscp2_V1_UpstreamResume {
    get {
      if case .upstreamResume(let v)? = metadata {return v}
      return Iscp2_V1_UpstreamResume()
    }
    set {metadata = .upstreamResume(newValue)}
  }

  var upstreamNormalClose: Iscp2_V1_UpstreamNormalClose {
    get {
      if case .upstreamNormalClose(let v)? = metadata {return v}
      return Iscp2_V1_UpstreamNormalClose()
    }
    set {metadata = .upstreamNormalClose(newValue)}
  }

  var downstreamOpen: Iscp2_V1_DownstreamOpen {
    get {
      if case .downstreamOpen(let v)? = metadata {return v}
      return Iscp2_V1_DownstreamOpen()
    }
    set {metadata = .downstreamOpen(newValue)}
  }

  var downstreamAbnormalClose: Iscp2_V1_DownstreamAbnormalClose {
    get {
      if case .downstreamAbnormalClose(let v)? = metadata {return v}
      return Iscp2_V1_DownstreamAbnormalClose()
    }
    set {metadata = .downstreamAbnormalClose(newValue)}
  }

  var downstreamResume: Iscp2_V1_DownstreamResume {
    get {
      if case .downstreamResume(let v)? = metadata {return v}
      return Iscp2_V1_DownstreamResume()
    }
    set {metadata = .downstreamResume(newValue)}
  }

  var downstreamNormalClose: Iscp2_V1_DownstreamNormalClose {
    get {
      if case .downstreamNormalClose(let v)? = metadata {return v}
      return Iscp2_V1_DownstreamNormalClose()
    }
    set {metadata = .downstreamNormalClose(newValue)}
  }

  var sourceNodeID: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamMetadataExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamMetadataExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Metadata: Equatable {
    case baseTime(Iscp2_V1_BaseTime)
    case upstreamOpen(Iscp2_V1_UpstreamOpen)
    case upstreamAbnormalClose(Iscp2_V1_UpstreamAbnormalClose)
    case upstreamResume(Iscp2_V1_UpstreamResume)
    case upstreamNormalClose(Iscp2_V1_UpstreamNormalClose)
    case downstreamOpen(Iscp2_V1_DownstreamOpen)
    case downstreamAbnormalClose(Iscp2_V1_DownstreamAbnormalClose)
    case downstreamResume(Iscp2_V1_DownstreamResume)
    case downstreamNormalClose(Iscp2_V1_DownstreamNormalClose)

  #if !swift(>=4.1)
    static func ==(lhs: Iscp2_V1_DownstreamMetadata.OneOf_Metadata, rhs: Iscp2_V1_DownstreamMetadata.OneOf_Metadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.baseTime, .baseTime): return {
        guard case .baseTime(let l) = lhs, case .baseTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamOpen, .upstreamOpen): return {
        guard case .upstreamOpen(let l) = lhs, case .upstreamOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamAbnormalClose, .upstreamAbnormalClose): return {
        guard case .upstreamAbnormalClose(let l) = lhs, case .upstreamAbnormalClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamResume, .upstreamResume): return {
        guard case .upstreamResume(let l) = lhs, case .upstreamResume(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upstreamNormalClose, .upstreamNormalClose): return {
        guard case .upstreamNormalClose(let l) = lhs, case .upstreamNormalClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamOpen, .downstreamOpen): return {
        guard case .downstreamOpen(let l) = lhs, case .downstreamOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamAbnormalClose, .downstreamAbnormalClose): return {
        guard case .downstreamAbnormalClose(let l) = lhs, case .downstreamAbnormalClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamResume, .downstreamResume): return {
        guard case .downstreamResume(let l) = lhs, case .downstreamResume(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.downstreamNormalClose, .downstreamNormalClose): return {
        guard case .downstreamNormalClose(let l) = lhs, case .downstreamNormalClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamMetadataExtensionFields? = nil
}

struct Iscp2_V1_DownstreamMetadataAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamMetadataAckExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamMetadataAckExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamMetadataAckExtensionFields? = nil
}

struct Iscp2_V1_UpstreamInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var streamID: Data = Data()

  var sourceNodeID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iscp2_V1_DownstreamChunkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var streamIDOfUpstream: Data = Data()

  var sequenceNumberInUpstream: UInt32 = 0

  var resultCode: Iscp2_V1_ResultCode = .succeeded

  var resultString: String = String()

  var extensionFields: Iscp2_V1_Extensions_DownstreamChunkResultExtensionFields {
    get {return _extensionFields ?? Iscp2_V1_Extensions_DownstreamChunkResultExtensionFields()}
    set {_extensionFields = newValue}
  }
  /// Returns true if `extensionFields` has been explicitly set.
  var hasExtensionFields: Bool {return self._extensionFields != nil}
  /// Clears the value of `extensionFields`. Subsequent reads from it will return its default value.
  mutating func clearExtensionFields() {self._extensionFields = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensionFields: Iscp2_V1_Extensions_DownstreamChunkResultExtensionFields? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Iscp2_V1_DownstreamOpenRequest: @unchecked Sendable {}
extension Iscp2_V1_DownstreamOpenResponse: @unchecked Sendable {}
extension Iscp2_V1_DownstreamResumeRequest: @unchecked Sendable {}
extension Iscp2_V1_DownstreamResumeResponse: @unchecked Sendable {}
extension Iscp2_V1_DownstreamCloseRequest: @unchecked Sendable {}
extension Iscp2_V1_DownstreamCloseResponse: @unchecked Sendable {}
extension Iscp2_V1_DownstreamChunk: @unchecked Sendable {}
extension Iscp2_V1_DownstreamChunk.OneOf_UpstreamOrAlias: @unchecked Sendable {}
extension Iscp2_V1_DownstreamChunkAck: @unchecked Sendable {}
extension Iscp2_V1_DownstreamChunkAckComplete: @unchecked Sendable {}
extension Iscp2_V1_DownstreamMetadata: @unchecked Sendable {}
extension Iscp2_V1_DownstreamMetadata.OneOf_Metadata: @unchecked Sendable {}
extension Iscp2_V1_DownstreamMetadataAck: @unchecked Sendable {}
extension Iscp2_V1_UpstreamInfo: @unchecked Sendable {}
extension Iscp2_V1_DownstreamChunkResult: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iscp2.v1"

extension Iscp2_V1_DownstreamOpenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamOpenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "desired_stream_id_alias"),
    3: .standard(proto: "downstream_filters"),
    4: .standard(proto: "expiry_interval"),
    5: .standard(proto: "data_id_aliases"),
    6: .same(proto: "qos"),
    7: .standard(proto: "extension_fields"),
    8: .standard(proto: "omit_empty_chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.desiredStreamIDAlias) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.downstreamFilters) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.expiryInterval) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: &self.dataIDAliases) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.qos) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.omitEmptyChunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.desiredStreamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.desiredStreamIDAlias, fieldNumber: 2)
    }
    if !self.downstreamFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.downstreamFilters, fieldNumber: 3)
    }
    if self.expiryInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiryInterval, fieldNumber: 4)
    }
    if !self.dataIDAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: self.dataIDAliases, fieldNumber: 5)
    }
    if self.qos != .unreliable {
      try visitor.visitSingularEnumField(value: self.qos, fieldNumber: 6)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.omitEmptyChunk != false {
      try visitor.visitSingularBoolField(value: self.omitEmptyChunk, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamOpenRequest, rhs: Iscp2_V1_DownstreamOpenRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.desiredStreamIDAlias != rhs.desiredStreamIDAlias {return false}
    if lhs.downstreamFilters != rhs.downstreamFilters {return false}
    if lhs.expiryInterval != rhs.expiryInterval {return false}
    if lhs.dataIDAliases != rhs.dataIDAliases {return false}
    if lhs.qos != rhs.qos {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.omitEmptyChunk != rhs.omitEmptyChunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamOpenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamOpenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "assigned_stream_id"),
    3: .standard(proto: "server_time"),
    4: .standard(proto: "result_code"),
    5: .standard(proto: "result_string"),
    6: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.assignedStreamID) }()
      case 3: try { try decoder.decodeSingularSInt64Field(value: &self.serverTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.assignedStreamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.assignedStreamID, fieldNumber: 2)
    }
    if self.serverTime != 0 {
      try visitor.visitSingularSInt64Field(value: self.serverTime, fieldNumber: 3)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 4)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 5)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamOpenResponse, rhs: Iscp2_V1_DownstreamOpenResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.assignedStreamID != rhs.assignedStreamID {return false}
    if lhs.serverTime != rhs.serverTime {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamResumeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "stream_id"),
    3: .standard(proto: "desired_stream_id_alias"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.desiredStreamIDAlias) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamID, fieldNumber: 2)
    }
    if self.desiredStreamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.desiredStreamIDAlias, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamResumeRequest, rhs: Iscp2_V1_DownstreamResumeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.desiredStreamIDAlias != rhs.desiredStreamIDAlias {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamResumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamResumeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamResumeResponse, rhs: Iscp2_V1_DownstreamResumeResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamCloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamCloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "stream_id"),
    3: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamID, fieldNumber: 2)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamCloseRequest, rhs: Iscp2_V1_DownstreamCloseRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamCloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamCloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamCloseResponse, rhs: Iscp2_V1_DownstreamCloseResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_alias"),
    2: .standard(proto: "upstream_info"),
    3: .standard(proto: "upstream_alias"),
    4: .standard(proto: "stream_chunk"),
    5: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      case 2: try {
        var v: Iscp2_V1_UpstreamInfo?
        var hadOneofValue = false
        if let current = self.upstreamOrAlias {
          hadOneofValue = true
          if case .upstreamInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.upstreamOrAlias = .upstreamInfo(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.upstreamOrAlias != nil {try decoder.handleConflictingOneOf()}
          self.upstreamOrAlias = .upstreamAlias(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._streamChunk) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 1)
    }
    switch self.upstreamOrAlias {
    case .upstreamInfo?: try {
      guard case .upstreamInfo(let v)? = self.upstreamOrAlias else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .upstreamAlias?: try {
      guard case .upstreamAlias(let v)? = self.upstreamOrAlias else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._streamChunk {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamChunk, rhs: Iscp2_V1_DownstreamChunk) -> Bool {
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs.upstreamOrAlias != rhs.upstreamOrAlias {return false}
    if lhs._streamChunk != rhs._streamChunk {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamChunkAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamChunkAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_alias"),
    2: .standard(proto: "ack_id"),
    3: .same(proto: "results"),
    4: .standard(proto: "upstream_aliases"),
    5: .standard(proto: "data_id_aliases"),
    6: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ackID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_UpstreamInfo>.self, value: &self.upstreamAliases) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: &self.dataIDAliases) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 1)
    }
    if self.ackID != 0 {
      try visitor.visitSingularUInt32Field(value: self.ackID, fieldNumber: 2)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 3)
    }
    if !self.upstreamAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_UpstreamInfo>.self, value: self.upstreamAliases, fieldNumber: 4)
    }
    if !self.dataIDAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Iscp2_V1_DataID>.self, value: self.dataIDAliases, fieldNumber: 5)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamChunkAck, rhs: Iscp2_V1_DownstreamChunkAck) -> Bool {
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs.ackID != rhs.ackID {return false}
    if lhs.results != rhs.results {return false}
    if lhs.upstreamAliases != rhs.upstreamAliases {return false}
    if lhs.dataIDAliases != rhs.dataIDAliases {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamChunkAckComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamChunkAckComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_alias"),
    2: .standard(proto: "ack_id"),
    3: .standard(proto: "result_code"),
    4: .standard(proto: "result_string"),
    5: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ackID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 1)
    }
    if self.ackID != 0 {
      try visitor.visitSingularUInt32Field(value: self.ackID, fieldNumber: 2)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 3)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 4)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamChunkAckComplete, rhs: Iscp2_V1_DownstreamChunkAckComplete) -> Bool {
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs.ackID != rhs.ackID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    13: .standard(proto: "stream_id_alias"),
    2: .standard(proto: "base_time"),
    3: .standard(proto: "upstream_open"),
    4: .standard(proto: "upstream_abnormal_close"),
    5: .standard(proto: "upstream_resume"),
    6: .standard(proto: "upstream_normal_close"),
    7: .standard(proto: "downstream_open"),
    8: .standard(proto: "downstream_abnormal_close"),
    9: .standard(proto: "downstream_resume"),
    10: .standard(proto: "downstream_normal_close"),
    11: .standard(proto: "source_node_id"),
    12: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try {
        var v: Iscp2_V1_BaseTime?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .baseTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .baseTime(v)
        }
      }()
      case 3: try {
        var v: Iscp2_V1_UpstreamOpen?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .upstreamOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .upstreamOpen(v)
        }
      }()
      case 4: try {
        var v: Iscp2_V1_UpstreamAbnormalClose?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .upstreamAbnormalClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .upstreamAbnormalClose(v)
        }
      }()
      case 5: try {
        var v: Iscp2_V1_UpstreamResume?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .upstreamResume(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .upstreamResume(v)
        }
      }()
      case 6: try {
        var v: Iscp2_V1_UpstreamNormalClose?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .upstreamNormalClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .upstreamNormalClose(v)
        }
      }()
      case 7: try {
        var v: Iscp2_V1_DownstreamOpen?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .downstreamOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .downstreamOpen(v)
        }
      }()
      case 8: try {
        var v: Iscp2_V1_DownstreamAbnormalClose?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .downstreamAbnormalClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .downstreamAbnormalClose(v)
        }
      }()
      case 9: try {
        var v: Iscp2_V1_DownstreamResume?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .downstreamResume(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .downstreamResume(v)
        }
      }()
      case 10: try {
        var v: Iscp2_V1_DownstreamNormalClose?
        var hadOneofValue = false
        if let current = self.metadata {
          hadOneofValue = true
          if case .downstreamNormalClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.metadata = .downstreamNormalClose(v)
        }
      }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.sourceNodeID) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.streamIDAlias) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    switch self.metadata {
    case .baseTime?: try {
      guard case .baseTime(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .upstreamOpen?: try {
      guard case .upstreamOpen(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .upstreamAbnormalClose?: try {
      guard case .upstreamAbnormalClose(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .upstreamResume?: try {
      guard case .upstreamResume(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .upstreamNormalClose?: try {
      guard case .upstreamNormalClose(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .downstreamOpen?: try {
      guard case .downstreamOpen(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .downstreamAbnormalClose?: try {
      guard case .downstreamAbnormalClose(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .downstreamResume?: try {
      guard case .downstreamResume(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .downstreamNormalClose?: try {
      guard case .downstreamNormalClose(let v)? = self.metadata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if !self.sourceNodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceNodeID, fieldNumber: 11)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if self.streamIDAlias != 0 {
      try visitor.visitSingularUInt32Field(value: self.streamIDAlias, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamMetadata, rhs: Iscp2_V1_DownstreamMetadata) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.streamIDAlias != rhs.streamIDAlias {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.sourceNodeID != rhs.sourceNodeID {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamMetadataAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamMetadataAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "result_code"),
    3: .standard(proto: "result_string"),
    4: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestID != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestID, fieldNumber: 1)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 2)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 3)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamMetadataAck, rhs: Iscp2_V1_DownstreamMetadataAck) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_UpstreamInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "stream_id"),
    3: .standard(proto: "source_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamID, fieldNumber: 2)
    }
    if !self.sourceNodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceNodeID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_UpstreamInfo, rhs: Iscp2_V1_UpstreamInfo) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.sourceNodeID != rhs.sourceNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iscp2_V1_DownstreamChunkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamChunkResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id_of_upstream"),
    2: .standard(proto: "sequence_number_in_upstream"),
    3: .standard(proto: "result_code"),
    4: .standard(proto: "result_string"),
    5: .standard(proto: "extension_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.streamIDOfUpstream) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sequenceNumberInUpstream) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.resultCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensionFields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamIDOfUpstream.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamIDOfUpstream, fieldNumber: 1)
    }
    if self.sequenceNumberInUpstream != 0 {
      try visitor.visitSingularUInt32Field(value: self.sequenceNumberInUpstream, fieldNumber: 2)
    }
    if self.resultCode != .succeeded {
      try visitor.visitSingularEnumField(value: self.resultCode, fieldNumber: 3)
    }
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 4)
    }
    try { if let v = self._extensionFields {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iscp2_V1_DownstreamChunkResult, rhs: Iscp2_V1_DownstreamChunkResult) -> Bool {
    if lhs.streamIDOfUpstream != rhs.streamIDOfUpstream {return false}
    if lhs.sequenceNumberInUpstream != rhs.sequenceNumberInUpstream {return false}
    if lhs.resultCode != rhs.resultCode {return false}
    if lhs.resultString != rhs.resultString {return false}
    if lhs._extensionFields != rhs._extensionFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
