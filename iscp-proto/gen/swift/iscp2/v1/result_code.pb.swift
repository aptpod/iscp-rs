// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: iscp2/v1/result_code.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Iscp2_V1_ResultCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case succeeded // = 0
  static let normalClosure = succeeded
  case incompatibleVersion // = 1
  case maximumDataIDAlias // = 2
  case maximumUpstreamAlias // = 3
  case unspecifiedError // = 64
  case noNodeID // = 65
  case authFailed // = 66
  case connectTimeout // = 67
  case malformedMessage // = 68
  case protocolError // = 69
  case ackTimeout // = 70
  case invalidPayload // = 71
  case invalidDataID // = 72
  case invalidDataIDAlias // = 73
  case invalidDataFilter // = 74
  case streamNotFound // = 75
  case resumeRequestConflict // = 76
  case processFailed // = 77
  case desiredQosNotSupported // = 78
  case pingTimeout // = 79
  case tooLargeMessageSize // = 80
  case tooManyDataIDAliases // = 81
  case tooManyStreams // = 82
  case tooLongAckInterval // = 83
  case tooManyDownstreamFilters // = 84
  case tooManyDataFilters // = 85
  case tooLongExpiryInterval // = 86
  case tooLongPingTimeout // = 87
  case tooShortPingInterval // = 88
  case tooShortPingTimeout // = 89
  case rateLimitReached // = 90
  case nodeIDMismatch // = 128
  case sessionNotFound // = 129
  case sessionAlreadyClosed // = 130
  case sessionCannotClosed // = 131
  case UNRECOGNIZED(Int)

  init() {
    self = .succeeded
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .succeeded
    case 1: self = .incompatibleVersion
    case 2: self = .maximumDataIDAlias
    case 3: self = .maximumUpstreamAlias
    case 64: self = .unspecifiedError
    case 65: self = .noNodeID
    case 66: self = .authFailed
    case 67: self = .connectTimeout
    case 68: self = .malformedMessage
    case 69: self = .protocolError
    case 70: self = .ackTimeout
    case 71: self = .invalidPayload
    case 72: self = .invalidDataID
    case 73: self = .invalidDataIDAlias
    case 74: self = .invalidDataFilter
    case 75: self = .streamNotFound
    case 76: self = .resumeRequestConflict
    case 77: self = .processFailed
    case 78: self = .desiredQosNotSupported
    case 79: self = .pingTimeout
    case 80: self = .tooLargeMessageSize
    case 81: self = .tooManyDataIDAliases
    case 82: self = .tooManyStreams
    case 83: self = .tooLongAckInterval
    case 84: self = .tooManyDownstreamFilters
    case 85: self = .tooManyDataFilters
    case 86: self = .tooLongExpiryInterval
    case 87: self = .tooLongPingTimeout
    case 88: self = .tooShortPingInterval
    case 89: self = .tooShortPingTimeout
    case 90: self = .rateLimitReached
    case 128: self = .nodeIDMismatch
    case 129: self = .sessionNotFound
    case 130: self = .sessionAlreadyClosed
    case 131: self = .sessionCannotClosed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .succeeded: return 0
    case .incompatibleVersion: return 1
    case .maximumDataIDAlias: return 2
    case .maximumUpstreamAlias: return 3
    case .unspecifiedError: return 64
    case .noNodeID: return 65
    case .authFailed: return 66
    case .connectTimeout: return 67
    case .malformedMessage: return 68
    case .protocolError: return 69
    case .ackTimeout: return 70
    case .invalidPayload: return 71
    case .invalidDataID: return 72
    case .invalidDataIDAlias: return 73
    case .invalidDataFilter: return 74
    case .streamNotFound: return 75
    case .resumeRequestConflict: return 76
    case .processFailed: return 77
    case .desiredQosNotSupported: return 78
    case .pingTimeout: return 79
    case .tooLargeMessageSize: return 80
    case .tooManyDataIDAliases: return 81
    case .tooManyStreams: return 82
    case .tooLongAckInterval: return 83
    case .tooManyDownstreamFilters: return 84
    case .tooManyDataFilters: return 85
    case .tooLongExpiryInterval: return 86
    case .tooLongPingTimeout: return 87
    case .tooShortPingInterval: return 88
    case .tooShortPingTimeout: return 89
    case .rateLimitReached: return 90
    case .nodeIDMismatch: return 128
    case .sessionNotFound: return 129
    case .sessionAlreadyClosed: return 130
    case .sessionCannotClosed: return 131
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Iscp2_V1_ResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Iscp2_V1_ResultCode] = [
    .succeeded,
    .incompatibleVersion,
    .maximumDataIDAlias,
    .maximumUpstreamAlias,
    .unspecifiedError,
    .noNodeID,
    .authFailed,
    .connectTimeout,
    .malformedMessage,
    .protocolError,
    .ackTimeout,
    .invalidPayload,
    .invalidDataID,
    .invalidDataIDAlias,
    .invalidDataFilter,
    .streamNotFound,
    .resumeRequestConflict,
    .processFailed,
    .desiredQosNotSupported,
    .pingTimeout,
    .tooLargeMessageSize,
    .tooManyDataIDAliases,
    .tooManyStreams,
    .tooLongAckInterval,
    .tooManyDownstreamFilters,
    .tooManyDataFilters,
    .tooLongExpiryInterval,
    .tooLongPingTimeout,
    .tooShortPingInterval,
    .tooShortPingTimeout,
    .rateLimitReached,
    .nodeIDMismatch,
    .sessionNotFound,
    .sessionAlreadyClosed,
    .sessionCannotClosed,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Iscp2_V1_ResultCode: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Iscp2_V1_ResultCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "SUCCEEDED", aliases: ["NORMAL_CLOSURE"]),
    1: .same(proto: "INCOMPATIBLE_VERSION"),
    2: .same(proto: "MAXIMUM_DATA_ID_ALIAS"),
    3: .same(proto: "MAXIMUM_UPSTREAM_ALIAS"),
    64: .same(proto: "UNSPECIFIED_ERROR"),
    65: .same(proto: "NO_NODE_ID"),
    66: .same(proto: "AUTH_FAILED"),
    67: .same(proto: "CONNECT_TIMEOUT"),
    68: .same(proto: "MALFORMED_MESSAGE"),
    69: .same(proto: "PROTOCOL_ERROR"),
    70: .same(proto: "ACK_TIMEOUT"),
    71: .same(proto: "INVALID_PAYLOAD"),
    72: .same(proto: "INVALID_DATA_ID"),
    73: .same(proto: "INVALID_DATA_ID_ALIAS"),
    74: .same(proto: "INVALID_DATA_FILTER"),
    75: .same(proto: "STREAM_NOT_FOUND"),
    76: .same(proto: "RESUME_REQUEST_CONFLICT"),
    77: .same(proto: "PROCESS_FAILED"),
    78: .same(proto: "DESIRED_QOS_NOT_SUPPORTED"),
    79: .same(proto: "PING_TIMEOUT"),
    80: .same(proto: "TOO_LARGE_MESSAGE_SIZE"),
    81: .same(proto: "TOO_MANY_DATA_ID_ALIASES"),
    82: .same(proto: "TOO_MANY_STREAMS"),
    83: .same(proto: "TOO_LONG_ACK_INTERVAL"),
    84: .same(proto: "TOO_MANY_DOWNSTREAM_FILTERS"),
    85: .same(proto: "TOO_MANY_DATA_FILTERS"),
    86: .same(proto: "TOO_LONG_EXPIRY_INTERVAL"),
    87: .same(proto: "TOO_LONG_PING_TIMEOUT"),
    88: .same(proto: "TOO_SHORT_PING_INTERVAL"),
    89: .same(proto: "TOO_SHORT_PING_TIMEOUT"),
    90: .same(proto: "RATE_LIMIT_REACHED"),
    128: .same(proto: "NODE_ID_MISMATCH"),
    129: .same(proto: "SESSION_NOT_FOUND"),
    130: .same(proto: "SESSION_ALREADY_CLOSED"),
    131: .same(proto: "SESSION_CANNOT_CLOSED"),
  ]
}
